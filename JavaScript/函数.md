## 默认值

```js
function log(x, y = 'World') {
  console.log(x, y);
}

log('Hello') // Hello World
log('Hello', 'China') // Hello China
log('Hello', '') // Hello

```

参数不能用`let`和`const`再次声明

```js
function foo(x = 5) {
  let x = 1; // error
  const x = 2; // error
}
```

length属性
length返回的是没有指定默认值的参数的个数

```js
(function (a) {}).length // 1
(function (a = 5) {}).length // 0
(function (a, b, c = 5) {}).length // 2
```

应用
参数省略报错

```js
function throwIfMissing() {
  throw new Error('Missing parameter');
}

function foo(mustBeProvided = throwIfMissing()) {
  return mustBeProvided;
}

foo()// Error: Missing parameter
```

## rest参数
rest参数用于获取函数的多余参数

```js
function push(array, ...items) {
  items.forEach(function(item) {
    array.push(item);
    console.log(item);
  });
}

var a = [];
push(a, 1, 2, 3)
```

## 箭头函数

```js
var f = v => v;

// 等同于
var f = function (v) {
  return v;
};



var f = () => 5;
// 等同于
var f = function () { return 5 };

var sum = (num1, num2) => num1 + num2;
// 等同于
var sum = function(num1, num2) {
  return num1 + num2;
};



// 报错
let getTempItem = id => { id: id, name: "Temp" };

// 不报错
let getTempItem = id => ({ id: id, name: "Temp" });


//简化
const isEven = n => n % 2 === 0;
const square = n => n * n;
```

与变量解构结合使用

```js
const full = ({ first, last }) => first + ' ' + last;

// 等同于
function full(person) {
  return person.first + ' ' + person.last;
}
```

简化回调函数

```js
// 正常函数写法
[1,2,3].map(function (x) {
  return x * x;
});

// 箭头函数写法
[1,2,3].map(x => x * x);


var result = values.sort(function (a, b) {
  return a - b;
});

// 箭头函数写法
var result = values.sort((a, b) => a - b);



//与rest参数结合
const numbers = (...nums) => nums;

numbers(1, 2, 3, 4, 5)
// [1,2,3,4,5]

const headAndTail = (head, ...tail) => [head, tail];

headAndTail(1, 2, 3, 4, 5)
// [1,[2,3,4,5]]
```

### 注意点
- 函数体内this对象，就是定义时所在的对象，而不是使用时所在的对象
- 不可以当作构造函数，不能用new命令
- 不可以使用arguments对象
- 不可以用yield命令，箭头函数不能用作Generator函数

### 不适用场景

```js
//定义函数的时候
const cat = {
  lives: 9,
  jumps: () => {
    this.lives--;
  }
}


//动态this的时候
var button = document.getElementById('press');
button.addEventListener('click', () => {
  this.classList.toggle('on');
});
```

## 双冒号函数
绑定，将左边的对象作为右边的上下文环境 `bind`,`call`,`apply`

```js
foo::bar;
// 等同于
bar.bind(foo);

foo::bar(...arguments);
// 等同于
bar.apply(foo, arguments);

const hasOwnProperty = Object.prototype.hasOwnProperty;
function hasOwn(obj, key) {
  return obj::hasOwnProperty(key);
}
```

## 尾调用优化
> 若是某个函数最后一步是调用另一个函数，就是尾调用

```js
//是尾调用
function f(x){
  return g(x);
}

function f(x) {
  if (x > 0) {
    return m(x)
  }
  return n(x);
}//m,n都是尾调用


//以下情况均不是尾调用
// 情况一
function f(x){
  let y = g(x);
  return y;
}

// 情况二
function f(x){
  return g(x) + 1;
}

// 情况三
function f(x){
  g(x);
}
```

## 尾递归

```js
function factorial(n) {
  if (n === 1) return 1;
  return n * factorial(n - 1);
}

factorial(5) // 120
//普通递归，浪费资源


function factorial(n, total) {
  if (n === 1) return total;
  return factorial(n - 1, n * total);
}

factorial(5, 1) // 120
//尾递归，只有一帧




function Fibonacci (n) {
  if ( n <= 1 ) {return 1};

  return Fibonacci(n - 1) + Fibonacci(n - 2);
}

Fibonacci(10) // 89
Fibonacci(100) // 堆栈溢出
Fibonacci(500) // 堆栈溢出
//普通递归，容易溢出


function Fibonacci2 (n , ac1 = 1 , ac2 = 1) {
  if( n <= 1 ) {return ac2};

  return Fibonacci2 (n - 1, ac2, ac1 + ac2);
}

Fibonacci2(100) // 573147844013817200000
Fibonacci2(1000) // 7.0330367711422765e+208
Fibonacci2(10000) // Infinity
//尾递归
```

要用尾递归，需要改写递归函数，确保最后一步只调用自身，需要将内部变量，中间变量都改成函数参数

> 尾调用优化只在严格模式下开启
`'use strict'`